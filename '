import express from "express";
import createHttpError from "http-errors";
import { randomUUID } from "crypto";
import { DataBase } from "../../database/DataBase.js";
import TopicService from "../../services/TopicService.js";
import { TopicModel } from "../../models/TopicModel.js";
import { logger } from "phileas";
import { RootTopic } from "../../root.js";
import assert from "assert";

type Req = express.Request;
type Res = express.Response;
type Next = express.NextFunction;

export namespace TopicResponse {
    export type GetTopicData = {
        currentPath: string;
        currentTopic: TopicModel;
        parentTopic: TopicModel | null;
    };

    export type GetTopic = TopicModel;
    export type PostTopics = GetTopicData;
    export type MoveTopic = GetTopicData;
}

function topicNotFound(id: string): { message: string } {
    return { message: `TopicModel with '${id}' not found.` };
}

function sendErr(next: Next, topicID: string): void {
    next(createHttpError(400, topicNotFound(topicID)));
}

async function getTopicData(req: Req, res: Res, next: Next): Promise<void> {
    const topicID = req.params.topicID;
    const data = await TopicService.getTopicDataById(topicID);

    if (!data) {
        return next(createHttpError(400, topicNotFound(topicID)));
    }

    const { rootTopic, ...topics } = data;
    res.status(200).json(topics satisfies TopicResponse.GetTopicData);
}

async function getTopic(req: Req, res: Res, next: Next): Promise<void> {
    const topicID = req.params.topicID;
    const topic = await TopicService.getTopicById(topicID);

    if (!topic) {
        return next(createHttpError(400, topicNotFound(topicID)));
    }

    res.status(200).json(topic satisfies TopicResponse.GetTopic);
}

async function postTopics(req: Req, res: Res, next: Next): Promise<void> {
    const topicID = req.params.topicID as string;
    const newTopicNames = req.body.newTopicNames as string[];

    const data = await TopicService.getTopicDataById(topicID);

    if (!data) {
        return next(createHttpError(400, topicNotFound(topicID)));
    }

    const set = new Set<string>();
    data.currentTopic.subTopics.forEach((subTopic) => set.add(subTopic.name));

    for (const newTopicName of newTopicNames) {
        if (!set.has(newTopicName)) {
            data.currentTopic.subTopics.push({
                id: randomUUID(),
                name: newTopicName,
                subTopics: [],
                questions: [],
            });
        }
    }

    const { rootTopic, ...topics } = data;
    await DataBase.saveDb(rootTopic);
    res.status(200).json(topics satisfies TopicResponse.PostTopics);
}

async function moveTopic(req: Req, res: Res, next: Next): Promise<void> {
    const topicID = req.params.topicID as string;
    const subTopicID = req.params.subTopicID as string;
    let dest = req.body.destination as string;

    let startDestID = topicID;
    if (dest.startsWith("~/") || dest.startsWith("/root/")) {
        startDestID = RootTopic.id;
        dest = dest.replace(/^~\/|^\/root\//, "");
    }

    if (dest.startsWith("./")) {
        dest = dest.replace(/^\.\//, "");
    }

    const fileData = await TopicService.getIndexableFileData();

    const rootTopic = fileData.root;
    const currentTopic = fileData.topics[topicID]?.topic;
    const parentTopic = fileData.topics[topicID]?.parent;
    const subTopic = fileData.topics[subTopicID]?.topic;
    const targetTopic = fileData.topics[startDestID]?.topic;

    if (!currentTopic || !subTopic || !targetTopic) {
        return sendErr(next, topicID);
    }

    let curr = targetTopic;
    const path = dest.split("/");
    for (let i = 0; i < path.length; ++i) {
        const name = path[i];

        const nextTopic = curr.subTopics.find((subTopic) => subTopic.name === name);
        if (!nextTopic && i < path.length - 1) {
            return sendErr(next, topicID);
        } else if (!nextTopic) {
            if (name !== ".") {
                targetTopic.name = name;
            }
        } else {
            curr = nextTopic;
        }
    }

    currentTopic.subTopics = currentTopic.subTopics.filter((topic) => {
        return topic.id !== subTopicID;
    });

    targetTopic.subTopics.push(targetTopic);

    await DataBase.saveDb(rootTopic);

    const topicData = await TopicService.getTopicDataById(topicID);

    res.status(200).json({
        currentTopic: currentTopic,
        parentTopic: parentTopic,
        currentPath: topicData?.currentPath ?? "",
    } satisfies TopicResponse.PostTopics);
}

export default {
    getTopicData,
    getTopic,
    postTopics,
    moveTopic,
};
